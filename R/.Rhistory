for( i in 1:scale){
x <- runif(1, min = -2, max = 2)
if ( (-1)>x || x>1){
y = rnorm(1, mean = 0,sd = 0.3)
}
else{
y = sin(x)+ rnorm(1, mean = 0, sd = 0.3)
}
xs[i] <- x
ys[i] <- y
}
plot((-200:200)/100,ft((-200:200)/100,scale),xlim = c(-2,2),ylim = c(-1,1))
plot((-200:200)/100,ftprox((-200:200)/100,scale),xlim = c(-2,2),ylim = c(-1,1))
plot((-200:200)/100,ft((-200:200)/100,scale),xlim = c(-2,2),ylim = c(-1,1))
plot((-200:200)/100,ftprox((-200:200)/100,scale),xlim = c(-2,2),ylim = c(-1,1))
set.seed(2)
count <- 0
scale <- 20
a <- 1
ys <- xs <- array(0,dim = scale)
ker <- function(x,y,s = 0.3){
return(exp(-(x-y)^2/(2*s^2)))
}
gam <- function(t,t0 = 1){
return(10000*a/(t+t0)^(0.5))
}
lam <- function(t,t0 = 1){
return(1/(a*(t+t0)^(0.5)))
}
# ft <- function(z,t){
#   gamm <- gam(t)
#   if(t>1){
#     p1 <- (1-gamm*lam(t))*ft(z,t-1)
#     p2 <- gamm * (ys[t] - ft(xs[t],t-1)) * ker(xs[t],z)
#     count <<- count + 1
#     return( p1+p2 )
#   }
#   else{
#     return(gamm*ys[1]*ker(xs[1],z))
#   }
# }
ft <- function(z,t){
# print(z)
gamm <- gam(t)
if(t>1){
val <- ft(c(xs[t],z),t-1)
p1 <- (1-gamm*lam(t))*val[-1]
p2 <- gamm * (ys[t] - val[1]) * ker(xs[t],z)
return( p1+p2 )
}
else{
return(gamm*ys[1]*ker(xs[1],z))
}
}
ftprox <- function(z,t){
# print(z)
gamm <- gam(t)
if(t>1){
val <- ftprox(c(xs[t],z),t-1)
p1 <- (1)*val[-1]
p2 <- gamm * (ys[t] - val[1]) * ker(xs[t],z)
return( (p1+p2)/(1+gamm*lam(t)) )
}
else{
return((gamm*ys[1]*ker(xs[1],z))/(1+gamm*lam(t)))
}
}
for( i in 1:scale){
x <- runif(1, min = -2, max = 2)
if ( (-1)>x || x>1){
y = rnorm(1, mean = 0,sd = 0.3)
}
else{
y = sin(x)+ rnorm(1, mean = 0, sd = 0.3)
}
xs[i] <- x
ys[i] <- y
}
plot((-200:200)/100,ft((-200:200)/100,scale),xlim = c(-2,2),ylim = c(-1,1))
plot((-200:200)/100,ftprox((-200:200)/100,scale),xlim = c(-2,2),ylim = c(-1,1))
set.seed(2)
count <- 0
scale <- 20
a <- 1
ys <- xs <- array(0,dim = scale)
ker <- function(x,y,s = 0.3){
return(exp(-(x-y)^2/(2*s^2)))
}
gam <- function(t,t0 = 1){
return(10000*a/(t+t0)^(0.5))
}
lam <- function(t,t0 = 1){
return(1/(a*(t+t0)^(0.5)))
}
# ft <- function(z,t){
#   gamm <- gam(t)
#   if(t>1){
#     p1 <- (1-gamm*lam(t))*ft(z,t-1)
#     p2 <- gamm * (ys[t] - ft(xs[t],t-1)) * ker(xs[t],z)
#     count <<- count + 1
#     return( p1+p2 )
#   }
#   else{
#     return(gamm*ys[1]*ker(xs[1],z))
#   }
# }
ft <- function(z,t){
# print(z)
gamm <- gam(t)
if(t>1){
val <- ft(c(xs[t],z),t-1)
p1 <- (1-gamm*lam(t))*val[-1]
p2 <- gamm * (ys[t] - val[1]) * ker(xs[t],z)
return( p1+p2 )
}
else{
return(gamm*ys[1]*ker(xs[1],z))
}
}
ftprox <- function(z,t){
# print(z)
gamm <- gam(t)
if(t>1){
val <- ftprox(c(xs[t],z),t-1)
p1 <- (1)*val[-1]
p2 <- gamm * (ys[t] - val[1]) * ker(xs[t],z)
return( (p1+p2)/(1+gamm*lam(t)) )
}
else{
return((gamm*ys[1]*ker(xs[1],z))/(1+gamm*lam(t)))
}
}
for( i in 1:scale){
x <- runif(1, min = -2, max = 2)
if ( (-1)>x || x>1){
y = rnorm(1, mean = 0,sd = 0.3)
}
else{
y = sin(x)+ rnorm(1, mean = 0, sd = 0.3)
}
xs[i] <- x
ys[i] <- y
}
plot((-200:200)/100,ft((-200:200)/100,scale),xlim = c(-2,2),ylim = c(-1,1))
plot((-200:200)/100,ftprox((-200:200)/100,scale),ylim = c(-1,1))
plot((-200:200)/100,ftprox((-200:200)/100,scale),ylim = c(-1,1))
set.seed(2)
count <- 0
scale <- 21
a <- 1
ys <- xs <- array(0,dim = scale)
ker <- function(x,y,s = 0.3){
return(exp(-(x-y)^2/(2*s^2)))
}
gam <- function(t,t0 = 1){
return(10000*a/(t+t0)^(0.5))
}
lam <- function(t,t0 = 1){
return(1/(a*(t+t0)^(0.5)))
}
# ft <- function(z,t){
#   gamm <- gam(t)
#   if(t>1){
#     p1 <- (1-gamm*lam(t))*ft(z,t-1)
#     p2 <- gamm * (ys[t] - ft(xs[t],t-1)) * ker(xs[t],z)
#     count <<- count + 1
#     return( p1+p2 )
#   }
#   else{
#     return(gamm*ys[1]*ker(xs[1],z))
#   }
# }
ft <- function(z,t){
# print(z)
gamm <- gam(t)
if(t>1){
val <- ft(c(xs[t],z),t-1)
p1 <- (1-gamm*lam(t))*val[-1]
p2 <- gamm * (ys[t] - val[1]) * ker(xs[t],z)
return( p1+p2 )
}
else{
return(gamm*ys[1]*ker(xs[1],z))
}
}
ftprox <- function(z,t){
# print(z)
gamm <- gam(t)
if(t>1){
val <- ftprox(c(xs[t],z),t-1)
p1 <- (1)*val[-1]
p2 <- gamm * (ys[t] - val[1]) * ker(xs[t],z)
return( (p1+p2)/(1+gamm*lam(t)) )
}
else{
return((gamm*ys[1]*ker(xs[1],z))/(1+gamm*lam(t)))
}
}
for( i in 1:scale){
x <- runif(1, min = -2, max = 2)
if ( (-1)>x || x>1){
y = rnorm(1, mean = 0,sd = 0.3)
}
else{
y = sin(x)+ rnorm(1, mean = 0, sd = 0.3)
}
xs[i] <- x
ys[i] <- y
}
plot((-200:200)/100,ft((-200:200)/100,scale),xlim = c(-2,2),ylim = c(-1,1))
plot((-200:200)/100,ftprox((-200:200)/100,scale),ylim = c(-1,1))
set.seed(2)
count <- 0
scale <- 22
a <- 1
ys <- xs <- array(0,dim = scale)
ker <- function(x,y,s = 0.3){
return(exp(-(x-y)^2/(2*s^2)))
}
gam <- function(t,t0 = 1){
return(10000*a/(t+t0)^(0.5))
}
lam <- function(t,t0 = 1){
return(1/(a*(t+t0)^(0.5)))
}
# ft <- function(z,t){
#   gamm <- gam(t)
#   if(t>1){
#     p1 <- (1-gamm*lam(t))*ft(z,t-1)
#     p2 <- gamm * (ys[t] - ft(xs[t],t-1)) * ker(xs[t],z)
#     count <<- count + 1
#     return( p1+p2 )
#   }
#   else{
#     return(gamm*ys[1]*ker(xs[1],z))
#   }
# }
ft <- function(z,t){
# print(z)
gamm <- gam(t)
if(t>1){
val <- ft(c(xs[t],z),t-1)
p1 <- (1-gamm*lam(t))*val[-1]
p2 <- gamm * (ys[t] - val[1]) * ker(xs[t],z)
return( p1+p2 )
}
else{
return(gamm*ys[1]*ker(xs[1],z))
}
}
ftprox <- function(z,t){
# print(z)
gamm <- gam(t)
if(t>1){
val <- ftprox(c(xs[t],z),t-1)
p1 <- (1)*val[-1]
p2 <- gamm * (ys[t] - val[1]) * ker(xs[t],z)
return( (p1+p2)/(1+gamm*lam(t)) )
}
else{
return((gamm*ys[1]*ker(xs[1],z))/(1+gamm*lam(t)))
}
}
for( i in 1:scale){
x <- runif(1, min = -2, max = 2)
if ( (-1)>x || x>1){
y = rnorm(1, mean = 0,sd = 0.3)
}
else{
y = sin(x)+ rnorm(1, mean = 0, sd = 0.3)
}
xs[i] <- x
ys[i] <- y
}
plot((-200:200)/100,ft((-200:200)/100,scale),xlim = c(-2,2),ylim = c(-1,1))
plot((-200:200)/100,ftprox((-200:200)/100,scale),ylim = c(-1,1))
set.seed(2)
count <- 0
scale <- 22
a <- 1
ys <- xs <- array(0,dim = scale)
ker <- function(x,y,s = 0.3){
return(exp(-(x-y)^2/(2*s^2)))
}
gam <- function(t,t0 = 1){
return(10000*a/(t+t0)^(0.5))
}
lam <- function(t,t0 = 1){
return(1/(a*(t+t0)^(0.5)))
}
# ft <- function(z,t){
#   gamm <- gam(t)
#   if(t>1){
#     p1 <- (1-gamm*lam(t))*ft(z,t-1)
#     p2 <- gamm * (ys[t] - ft(xs[t],t-1)) * ker(xs[t],z)
#     count <<- count + 1
#     return( p1+p2 )
#   }
#   else{
#     return(gamm*ys[1]*ker(xs[1],z))
#   }
# }
ft <- function(z,t){
# print(z)
gamm <- gam(t)
if(t>1){
val <- ft(c(xs[t],z),t-1)
p1 <- (1-gamm*lam(t))*val[-1]
p2 <- gamm * (ys[t] - val[1]) * ker(xs[t],z)
return( p1+p2 )
}
else{
return(gamm*ys[1]*ker(xs[1],z))
}
}
ftprox <- function(z,t){
# print(z)
gamm <- gam(t)
if(t>1){
val <- ftprox(c(xs[t],z),t-1)
p1 <- (1)*val[-1]
p2 <- gamm * (ys[t] - val[1]) * ker(xs[t],z)
return( (p1+p2)/(1+gamm*lam(t)) )
}
else{
return((gamm*ys[1]*ker(xs[1],z))/(1+gamm*lam(t)))
}
}
for( i in 1:scale){
x <- runif(1, min = -2, max = 2)
if ( (-1)>x || x>1){
y = rnorm(1, mean = 0,sd = 0.3)
}
else{
y = sin(x)+ rnorm(1, mean = 0, sd = 0.3)
}
xs[i] <- x
ys[i] <- y
}
plot((-200:200)/100,ft((-200:200)/100,scale),xlim = c(-2,2),ylim = c(-1,1))
plot((-200:200)/100,ftprox((-200:200)/100,scale),xlim = c(-2,2),ylim = c(-1,1))
set.seed(2)
count <- 0
scale <- 22
a <- 1
ys <- xs <- array(0,dim = scale)
ker <- function(x,y,s = 0.3){
return(exp(-(x-y)^2/(2*s^2)))
}
gam <- function(t,t0 = 1){
return(a/(t+t0)^(0.5))
}
lam <- function(t,t0 = 1){
return(1/(a*(t+t0)^(0.5)))
}
# ft <- function(z,t){
#   gamm <- gam(t)
#   if(t>1){
#     p1 <- (1-gamm*lam(t))*ft(z,t-1)
#     p2 <- gamm * (ys[t] - ft(xs[t],t-1)) * ker(xs[t],z)
#     count <<- count + 1
#     return( p1+p2 )
#   }
#   else{
#     return(gamm*ys[1]*ker(xs[1],z))
#   }
# }
ft <- function(z,t){
# print(z)
gamm <- gam(t)
if(t>1){
val <- ft(c(xs[t],z),t-1)
p1 <- (1-gamm*lam(t))*val[-1]
p2 <- gamm * (ys[t] - val[1]) * ker(xs[t],z)
return( p1+p2 )
}
else{
return(gamm*ys[1]*ker(xs[1],z))
}
}
ftprox <- function(z,t){
# print(z)
gamm <- gam(t)
if(t>1){
val <- ftprox(c(xs[t],z),t-1)
p1 <- (1)*val[-1]
p2 <- gamm * (ys[t] - val[1]) * ker(xs[t],z)
return( (p1+p2)/(1+gamm*lam(t)) )
}
else{
return((gamm*ys[1]*ker(xs[1],z))/(1+gamm*lam(t)))
}
}
for( i in 1:scale){
x <- runif(1, min = -2, max = 2)
if ( (-1)>x || x>1){
y = rnorm(1, mean = 0,sd = 0.3)
}
else{
y = sin(x)+ rnorm(1, mean = 0, sd = 0.3)
}
xs[i] <- x
ys[i] <- y
}
plot((-200:200)/100,ft((-200:200)/100,scale),xlim = c(-2,2),ylim = c(-1,1))
plot((-200:200)/100,ftprox((-200:200)/100,scale),xlim = c(-2,2),ylim = c(-1,1))
set.seed(2)
count <- 0
scale <- 2000
a <- 1
ys <- xs <- array(0,dim = scale)
ker <- function(x,y,s = 0.3){
return(exp(-(x-y)^2/(2*s^2)))
}
gam <- function(t,t0 = 1){
return(a/(t+t0)^(0.5))
}
lam <- function(t,t0 = 1){
return(1/(a*(t+t0)^(0.5)))
}
# ft <- function(z,t){
#   gamm <- gam(t)
#   if(t>1){
#     p1 <- (1-gamm*lam(t))*ft(z,t-1)
#     p2 <- gamm * (ys[t] - ft(xs[t],t-1)) * ker(xs[t],z)
#     count <<- count + 1
#     return( p1+p2 )
#   }
#   else{
#     return(gamm*ys[1]*ker(xs[1],z))
#   }
# }
ft <- function(z,t){
# print(z)
gamm <- gam(t)
if(t>1){
val <- ft(c(xs[t],z),t-1)
p1 <- (1-gamm*lam(t))*val[-1]
p2 <- gamm * (ys[t] - val[1]) * ker(xs[t],z)
return( p1+p2 )
}
else{
return(gamm*ys[1]*ker(xs[1],z))
}
}
ftprox <- function(z,t){
# print(z)
gamm <- gam(t)
if(t>1){
val <- ftprox(c(xs[t],z),t-1)
p1 <- (1)*val[-1]
p2 <- gamm * (ys[t] - val[1]) * ker(xs[t],z)
return( (p1+p2)/(1+gamm*lam(t)) )
}
else{
return((gamm*ys[1]*ker(xs[1],z))/(1+gamm*lam(t)))
}
}
for( i in 1:scale){
x <- runif(1, min = -2, max = 2)
if ( (-1)>x || x>1){
y = rnorm(1, mean = 0,sd = 0.3)
}
else{
y = sin(x)+ rnorm(1, mean = 0, sd = 0.3)
}
xs[i] <- x
ys[i] <- y
}
plot((-200:200)/100,ft((-200:200)/100,scale),xlim = c(-2,2),ylim = c(-1,1))
plot((-200:200)/100,ftprox((-200:200)/100,scale),xlim = c(-2,2),ylim = c(-1,1))
#r <- crossprod(X,y)
r <- X %*% y
scale <- 2e2
y <- matrix(rnorm(scale))
# ylong <- matrix(rnorm(scale*10))
X <-matrix( rnorm(scale*scale),ncol = scale)
# Xlong <-matrix( X,ncol = scale*10)
system.time(x %*% y)
y <- matrix(rnorm(scale))
# ylong <- matrix(rnorm(scale*10))
X <-matrix( rnorm(scale*scale),ncol = scale)
# Xlong <-matrix( X,ncol = scale*10)
system.time(X %*% y)
# Xlong <-matrix( X,ncol = scale*10)
system.time(
for(i in 1:10){
r <- parallelCorssProduct(X,y)
})
system.time(
for(i in 1:10){
r <- X %*% y
})
system.time(
for(i in 1:100){
r <- X %*% y
})
6.95/0.29
28.645/1.27
10^(2.1)
10^(2.1)*60/20
MKL_NUM_THREADS
a <- matrix(c(1,2,3,4),ncol = 2)
diag(a)
1/diag(a)
grm <- matrix(c(4,2,2,4),ncol = 2)
b <- c(1,2)
solve(grm,b)
set.seed(74349)#Generate classes with different meansmu.1 <-c(-2,-2)mu.2 <-c(0,3)mu.3 <-c(1,0)#same covariance matrixsigma <-matrix(c(2,0.5,0.5,2),2)#multivariate normal distributionsdata.1 <-mvrnorm(n=50,mu = mu.1, Sigma = sigma)data.2 <-mvrnorm(n=50,mu = mu.2, Sigma = sigma)data.3<-mvrnorm(n=50,mu = mu.3, Sigma = sigma)data<-rbind(data.1,data.2,data.3)#label <- factor(c(rep('red',50)), c(rep('green',50)), c(rep('blue',50)))labels<-c(rep(1,50),rep(2,50),rep(3,50))data.df <-data.frame('x1'= data[,1],'x2'= data[,2],'y'=labels)
sample(10,1:10)
sample(1:10,10)
exp(3.5)
